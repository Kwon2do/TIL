<h1>배열의 모든 것(with 자바스크립트 Deep Dive)</h1>

**배열이란?**<br>동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말함.

`장점`

- 읽기,쓰기와 같은 참조에는 O(1)의 성능을 가진다.

`단점`

- 크기 예측이 힘들기 때문에 메모리 낭비가 발생할 수 있다.
- 데이터 삽입, 삭제가 비효율적이다.

### JS에서 배열을 만드는 방법

1. `배열 리터럴 대괄호([ ])`로 생성하는 방법

2. `Array() 생성자`로 생성하는 방법

3. `Array.of 메서드`로 생성하는 방법

4. `Array.from 메서드`로 생성하는 방법

```javascript
//배열 리터럴을 사용하는 방법
let arr = [];
arr[0] = "W";
arr[1] = "E";
arr[2] = "B";

//Array() 생성자를 사용하는 방법
//전달인수가 1개(숫자)이면 길이, 2개 이상이면 요소로 갖는다.
let arr = new Array(); // -> []
arr[0] = "W";
arr[1] = "E";
arr[2] = "B";

//Array.of 메서드를 사용하는 방법
//전달 인수가 1개이고 숫자여도, 해당 인수를 요소로 가짐
let arr = Array.of(1);

//Array.from 메서드를 사용하는 방법

//(1)유사배열 객체를 변환해서 배열을 생성한다.
let arr = Array.from({
  length: 2,
  0: "a",
  1: "b",
});
console.log(arr); //['a','b']

//(2)이터러블을 변환하여 배열을 생성한다.(Ex:문자열)
let arr = Array.from("HELLO");
console.log(arr); //['H','E','L','L','O']

//(3)Array.from은 두 번째 인수로 전달한 콜백함수의 반환값으로 구성된 배열을 반환할 수도 있다.
let arr = Array.from({ length: 3 }, (_, i) => i);
console.log(arr); //[0,1,2]
```

> **배열 리터럴 vs Array()**<br>
> 배열 리터럴을 사용하여 배열을 생성하더라도 `내부적으로 Array() 생성자 함수를 사용하여 생성`하므로 **기능상의 차이는 없다**

### 자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.

자바스크립트 배열은 `인덱스를 나타내는 문자열을 프로퍼티 키`로 가지며, `length 프로퍼티`를 갖는 특수한 객체다.

자바스크립트 `배열의 요소는 사실 프로퍼티 값`인 것이다.
**따라서, 어떤 타입의 값이라도 배열의 요소(프로퍼티 값)가 될 수 있다.**

원래 배열은 `동일한 한 가지 자료형으로만 구성되어, 자료가 서로 연속되어 나열된 자료구조`이다.(=**밀집배열**)<br>

그러나, `자바스크립트의 배열은 한 가지 이상의 자료형을 허용`하기 때문에 하나의 데이터가 차지하는 메모리 공간이 불규칙할 수 있고 그렇기 때문에 `서로 연속적으로 나열되어있지 않을 수도 있는 자료구조`다.(=**희소 배열**)

심지어, **`배열의 크기 또한 동적으로 할당이 가능`** 하다.

**그렇다면, 자바스크립트는 왜 오리지널 배열을 선택하지 않았을까?**<br>
요소 접근에 있어서는 오리지널 배열의 성능이 우수하지만,배열의 요소를 삽입/삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 이동시킬 필요가 없기 때문에 매우 빠름.<br>
또한, 요소 접근이 느릴 수밖에 없는 단점을 보완하기 위해 대부분 모던 자바스크립트 엔진은 `배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화하여 구현`했다.

**⭐어쨌든, 배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다**

### length 프로퍼티 값을 변경한다면?

```javascript
//length 값을 줄였을 때, 요소도 함께 삭제됨.
const arr = [1, 2, 3, 4, 5];
arr.length = 3;
console.log(arr); //[1,2,3]

//length 값을 늘렸을 때, 아무 동작도 하지 않음.
const arr = [1];
arr.length = 3;
console.log(arr); //[1, empty × 2]
```

**length값을 늘렸을 때**, 값은 성공적으로 변경되지만 실제 배열에는 아무런 변함이 없다. **`값없이 비어있는 요소를 위해 메모리 공간을 확보하지 않으며, 빈 요소를 생성하지도 않는다.`**

**따라서, 자바스크립트 배열(희소배열)에서의 length값은 요소의 개수와 항상 일치하진 않는다.**

```javascript
const sparse = [, 2, , 4];
console.log(sparse.length); // 4
console.log(sparse); //[empty,2,empty,4]
```

### 배열 요소 추가

자바스크립트에서의 `배열은 객체`라고 했다.

그저, 객체에 프로퍼티를 추가하는 것이다.

```javascript
const arr = [];
//배열 요소의 추가
arr[0] = 1;
arr["1"] = 2; // -> arr[1] = 2;

//프로퍼티 추가
arr["foo"] = 3;
arr.bar = 4; //arr객체에 있는 bar 프로퍼티 값을 4로 !
arr[1.1] = 5;
arr[-1] = 6;

console.log(arr);
//[1,2,foo:3,bar:4,'1.1':5, '-1':6]
console.log(arr.length);
//2 (프로퍼티는 length에 영향을 주지 않는다!)
```

### 배열 요소 삭제

배열은 객체이기 때문에 배열의 특정 요소를 삭제하기 위해 `delete 연산자`를 사용할 수 있다.

```javascript
const arr = [1, 2, 3];

//배열 요소의 삭제
delete arr[1];
console.log(arr); //[1,empty,3]
// length 프로퍼티에 영향을 주지 않는다.
// 희소 배열이 되는 것이다.
console.log(arr.length); // 3
```

위 처럼, delete를 사용해서 요소를 삭제해도 length 프로퍼티 값에는 영향을 주지 않는다.

그저 가운데가 뚫린 **희소배열**이 되는 것일 뿐..<br>
`따라서, delete 연산자는 사용하지 않는 것이 좋다`

희소 배열을 만들지 않으면서, **배열의 특정 요소를 완전히 삭제**하려면 `Array.prototype.splice 메서드`를 사용한다.

```javascript
const arr = [1, 2, 3];
//Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)
arr.splice(1, 1); //arr[1]부터 1개의 요소를 제거
console.log(arr); //[1,3]
console.log(arr.length); //2
```

### 배열 메서드

배열의 메서드는 2가지 종류로 나눌 수 있다.

- 원본 배열을 직접 변경하는가?
- 새로운 배열을 생성하여 반환하는가?

`예시`

```javascript
const arr = [1];
arr.push(2);
console.log(arr); //[1,2] -> push는 원본 배열을 직접 변경한다.

const result = arr.concat(3);
console.log(arr); //[1,2]
console.log(result); //[1,2,3] -> concat 메소드는 새로운 배열을 반환
```

원본 배열을 수정하게 되면, 예상치 못한 동작 오류 가능성이 높아지게 되므로 **`가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 것이 좋다.`**

#### Array 생성자 함수의 정적 메서드

- `Array.isArray`<br>
  전달된 인수가 **배열이면 true, 아니면 false 반환**

- `Array.of`
  전달 인수가 1개이고 숫자여도, **해당 인수를 요소로 가지는 배열을 생성**

- `Array.from`
  유사배열 객체를 변환 또는 이터러블 **변환 후 배열 생성**<br>
  (위에서 언급한 배열 생성 코드 참고)

#### Array.prototype 메서드

- `Array.indexof`<br>
    인수로 전달된 **요소 검색 후 인덱스 반환**한다.(중복시 첫 번째 요소 반환,
    존재하지 않는다면 -1을 반환)<br>
    **두 번째 인수는 검색을 시작할 인덱스**이다. (비어있으면 처음부터 검색)

- `Array.includes`<br>
  인수로 **전달된 요소의 존재 여부를 반환**한다

- `push`<br>
  인수로 전달받은 모든 값을 **원본 배열의 마지막 요소로 추가**한 후, **변경된 length 프로퍼티 값을 반환**한다. (**원본 배열 직접 변경**)

    > **push메서드는 성능 면에서 좋지 않다.**<br>
마지막 요소에 추가할 요소가 하나뿐이라면, `length프로퍼티를 사용해서 배열의 마지막 요소에 직접 추가`할 수 있고, 실제로 이 방법이 더 빠르다.
또한, 원본 배열을 직접 변경하는 것은 좋지 않다. 따라서, `ES6 스프레드 문법을 사용하는 편이 좋다.`

- `pop`<br>
  원본 배열에서 **마지막 요소를 제거 후, 제거한 요소를 반환**한다.
  원본 배열이 빈 배열이면 undefined를 반환한다.<br>
  push메서드와 마찬가지로, **원본 배열을 직접 변경**한다.

- `unshift`<br>
  원본 배열의 **선두에 요소를 추가**하고, **변경된 length 프로퍼티 값을 반환**
  마찬가지로, `ES6 스프레드 문법을 사용하는 편이 좋다.`

- `shift`<br>
  원본 배열에서 **첫 번째 요소를 제거**하고, **제거한 요소를 반환**한다.

    > `push&pop`은 **StacK(FILO)** 을, `push&shift`는 **Queue(FIFO)** 자료구조를 구현할 수 있다.

- `concat`<br>
  인수로 전달된 값들을 **원본 배열의 마지막 요소로 추가한 새로운 배열을 반환**한다.`(원본 배열은 변경되지 않는다)`
  
  > `concat 메서드로 push와 unshift 메서드를 대체할 수 있다.` 또한, concat메서드는 `스프레드 문법으로 대체`될 수 있다.<br>
  따라서, push/unshift/concat 메서드를 사용하기 보다 **`ES6의 스프레드 문법을 일관성있게 사용하는 것을 권장.`**

  ~~~javascript
  let result = [1,2].concat([3,4]);
  console.log(result); //[1,2,3,4]

  result = [...[1.2], ...[3,4]];
  console.log(result); //[1,2,3,4]
  ~~~

- `splice`<br>
원본 배열의 **중간에 요소를 추가/제거**하는 경우 사용한다.<br>
**3개의 매개변수**가 있고, `원본 배열을 직접 변경`한다.<br><br>
매개변수1) 배열 요소 **삭제를 시작할 인덱스** (음수인 경우 뒤에서, -1:마지막)<br>
매개변수2) **제거할 요소 개수**(0이면 아무것도 제거하지 않는다는 것)<br>
매개변수3) 제거한 위치에 **삽입할 요소들의 목록**

~~~javascript
const arr = [1,2,3,4];
const result = arr.splice(1,2,20,30);
console.log(result); //[2,3] 제거한 요소 반환
console.log(arr); //[1,20,30,4]
~~~

- `slice` (얕은 복사)<br>
인수로 전달된 범위의 **요소들을 복사하여 새로운 배열로 반환**한다.<br>
매개변수는 start,end 2개이고, end 인덱스는 포함되지 않는다.

- `join` <br>
원본 **배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열, 즉 구분자로 연결한 문자열을 반환**한다.
~~~javascript
const arr = [1,2,3,4];
arr.join() // '1,2,3,4'
arr.join('') // '1234'
arr.join(':') // '1:2:3:4'
~~~

- `reverse`<br>
원본 배열의 순서를 **반대로 뒤집는다.** (원본 배열이 변경된다)<br>
**변경된 배열을 반환**한다.

- `fill`<br>
인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다.<br>
원본 배열이 변경되고, 매개변수는 3개를 가진다.<br>
~~~javascript
const arr = [1,2,3];
arr.fill(0);
console.log(arr); //[0,0,0]

arr.fill(0,1); // 0을 배열의 인덱스1부터 끝까지 요소로 채운다.
console.log(arr); //[1,0,0]

arr.fill(0,0,2); // 0을 인덱스0부터 2이전까지 요소로 채운다.
console.log(arr); // [0,0,2]
~~~

- `flat` <br>
인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.<br>
쉽게 말해서, 중첩 배열이 있으면 대괄호를 벗겨주는 것.<br>
인수로 Infinity를 전달하면, 중첩 배열 모두를 평탄화한다.